---
title: Hilt Dependency Injection — Scoping and Assisted Injection
impact: HIGH
tags: dependency-injection, hilt, scoping, assisted-inject
---

## Hilt Dependency Injection — Scoping and Assisted Injection

Scope bindings to the narrowest appropriate lifecycle. Use assisted injection for runtime parameters instead of forcing them through the DI graph.

### Lifecycle-Appropriate Scoping

Avoid `@Singleton` for everything — it keeps objects alive for the entire app lifetime.

**Incorrect:**

```kotlin
// Bad - everything as Singleton
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    @Provides
    @Singleton  // Caches user data forever, even after logout
    fun provideUserCache(): UserCache = InMemoryUserCache()

    @Provides
    @Singleton  // Screen-specific object as Singleton — memory waste
    fun provideCheckoutPresenter(): CheckoutPresenter = CheckoutPresenter()
}
```

**Correct:**

```kotlin
// Good - app-wide: expensive, truly shared objects
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(context, AppDatabase::class.java, "app.db").build()
    }

    @Provides
    @Singleton  // OkHttpClient is expensive to create, share it
    fun provideOkHttpClient(): OkHttpClient = OkHttpClient.Builder().build()
}

// Good - activity-retained: survives rotation, cleared on Activity finish
@Module
@InstallIn(ActivityRetainedComponent::class)
object ActivityModule {
    @Provides
    @ActivityRetainedScoped
    fun provideUserCache(): UserCache = InMemoryUserCache()
}

// Good - unscoped: cheap objects get a new instance per injection
@Module
@InstallIn(ViewModelComponent::class)
object ViewModelModule {
    @Provides  // No scope annotation — new instance each time
    fun provideMapper(): UserMapper = UserMapper()
}
```

**Scope reference:**

| Component | Scope | Lifetime |
|-----------|-------|----------|
| `SingletonComponent` | `@Singleton` | App process |
| `ActivityRetainedComponent` | `@ActivityRetainedScoped` | Survives rotation |
| `ViewModelComponent` | `@ViewModelScoped` | ViewModel lifetime |
| `ActivityComponent` | `@ActivityScoped` | Activity instance |
| `FragmentComponent` | `@FragmentScoped` | Fragment instance |

### Assisted Injection for Runtime Parameters

When a class needs both DI-provided dependencies and runtime values (user ID, quality setting, navigation args), use `@AssistedInject` instead of hardcoding or using mutable holders.

**Incorrect:**

```kotlin
// Bad - runtime value hardcoded in module
@Provides
fun provideImageProcessor(@ApplicationContext context: Context): ImageProcessor {
    return ImageProcessor(context, quality = 80)  // Where does 'quality' come from?
}

// Bad - mutable holder to pass runtime values
class ImageProcessorHolder @Inject constructor() {
    var quality: Int = 80  // Mutable shared state — race conditions
}
```

**Correct:**

```kotlin
// Good - @AssistedInject separates DI deps from runtime params
class ImageProcessor @AssistedInject constructor(
    @ApplicationContext private val context: Context,  // DI-provided
    @Assisted private val quality: Int                  // Runtime param
) {
    fun process(bitmap: Bitmap): Bitmap { /* ... */ }
}

// Good - factory interface generated by Hilt
@AssistedFactory
interface ImageProcessorFactory {
    fun create(quality: Int): ImageProcessor
}

// Good - usage in ViewModel
@HiltViewModel
class EditViewModel @Inject constructor(
    private val processorFactory: ImageProcessorFactory
) : ViewModel() {

    fun processImage(bitmap: Bitmap, quality: Int) {
        val processor = processorFactory.create(quality)
        // ...
    }
}
```

**When to use assisted injection:**
- Workers that need runtime configuration (quality, URL, retry count)
- Screen-specific services that depend on navigation arguments
- Any class where some parameters come from DI and others from the caller

**Why it matters:**
- Over-scoping wastes memory; under-scoping creates redundant instances and breaks shared state
- Incorrect scoping causes subtle bugs (stale caches after logout, leaked connections)
- Assisted injection keeps the DI graph clean — runtime parameters are explicit, not hidden
- Factory is generated by Hilt — no manual factory implementation needed

Reference: [Scoping in Hilt](https://developer.android.com/training/dependency-injection/hilt-android#component-scopes) | [Assisted injection](https://dagger.dev/dev-guide/assisted-injection.html)
