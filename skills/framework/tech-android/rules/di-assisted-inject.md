---
title: Use Assisted Injection for Runtime Parameters
impact: MEDIUM
tags: dependency-injection, hilt, assisted-inject
---

## Use Assisted Injection for Runtime Parameters

When a class needs both DI-provided dependencies and runtime values (like a user ID or configuration), use `@AssistedInject` instead of passing runtime values through the DI graph.

**Incorrect (runtime values in DI graph):**

```kotlin
// Bad - runtime parameter forced into DI module
@Module
@InstallIn(ViewModelComponent::class)
object WorkerModule {
    @Provides
    fun provideImageProcessor(
        @ApplicationContext context: Context
    ): ImageProcessor {
        // Where does 'quality' come from? Can't inject runtime values!
        return ImageProcessor(context, quality = 80)  // Hardcoded!
    }
}

// Bad - using a mutable holder to pass runtime values
class ImageProcessorHolder @Inject constructor() {
    var quality: Int = 80  // Mutable shared state — race conditions
    lateinit var processor: ImageProcessor
}
```

**Correct (assisted injection):**

```kotlin
// Good - @AssistedInject separates DI deps from runtime params
class ImageProcessor @AssistedInject constructor(
    @ApplicationContext private val context: Context,  // DI-provided
    @Assisted private val quality: Int                  // Runtime param
) {
    fun process(bitmap: Bitmap): Bitmap { /* ... */ }
}

// Good - factory interface generated by Hilt
@AssistedFactory
interface ImageProcessorFactory {
    fun create(quality: Int): ImageProcessor
}

// Good - usage in ViewModel
@HiltViewModel
class EditViewModel @Inject constructor(
    private val processorFactory: ImageProcessorFactory
) : ViewModel() {

    fun processImage(bitmap: Bitmap, quality: Int) {
        viewModelScope.launch {
            val processor = processorFactory.create(quality)
            val result = processor.process(bitmap)
            _processedImage.value = result
        }
    }
}
```

**When to use assisted injection:**
- Workers that need runtime configuration (quality, URL, retry count)
- Screen-specific services that depend on navigation arguments
- Factories where some parameters come from DI and others from the caller

**Why it matters:**
- Avoids hardcoding runtime values or using mutable holders
- Factory is generated by Hilt — no manual factory implementation
- Runtime parameters are explicit in the constructor, not hidden
- Keeps the DI graph clean — only truly injectable dependencies are modules

Reference: [Assisted injection — Hilt](https://dagger.dev/dev-guide/assisted-injection.html)
